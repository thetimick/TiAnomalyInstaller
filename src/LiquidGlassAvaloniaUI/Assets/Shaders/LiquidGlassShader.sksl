// Liquid Glass SKSL Shader (Lens refraction + dispersion)
// Adapted to Avalonia + SkiaSharp (SKRuntimeEffect).

uniform shader content;

uniform float2 size;                 // Control size (DIP in Avalonia coordinates)
uniform float4 cornerRadii;          // [topLeft, topRight, bottomRight, bottomLeft]
uniform float refractionHeight;      // Edge band thickness (DIP)
uniform float refractionAmount;      // Refraction strength (DIP)
uniform float depthEffect;           // 0..1
uniform float chromaticAberration;   // 0..1

float radiusAt(float2 centeredCoord, float4 radii) {
    if (centeredCoord.x >= 0.0) {
        if (centeredCoord.y < 0.0) return radii.y;
        else return radii.z;
    } else {
        if (centeredCoord.y < 0.0) return radii.x;
        else return radii.w;
    }
}

float sdRoundedRect(float2 coord, float2 halfSize, float radius) {
    float2 cornerCoord = abs(coord) - (halfSize - float2(radius));
    float outside = length(max(cornerCoord, 0.0)) - radius;
    float inside = min(max(cornerCoord.x, cornerCoord.y), 0.0);
    return outside + inside;
}

float2 gradSdRoundedRect(float2 coord, float2 halfSize, float radius) {
    float2 cornerCoord = abs(coord) - (halfSize - float2(radius));
    if (cornerCoord.x >= 0.0 || cornerCoord.y >= 0.0) {
        return sign(coord) * normalize(max(cornerCoord, 0.0));
    } else {
        float gradX = step(cornerCoord.y, cornerCoord.x);
        return sign(coord) * float2(gradX, 1.0 - gradX);
    }
}

float circleMap(float x) {
    x = clamp(x, 0.0, 1.0);
    return 1.0 - sqrt(1.0 - x * x);
}

half4 sampleDispersed(float2 refractedCoord, float2 dispersedCoord) {
    half4 color = half4(0.0);

    half4 red = content.eval(refractedCoord + dispersedCoord);
    color.r += red.r / 3.5;
    color.a += red.a / 7.0;

    half4 orange = content.eval(refractedCoord + dispersedCoord * (2.0 / 3.0));
    color.r += orange.r / 3.5;
    color.g += orange.g / 7.0;
    color.a += orange.a / 7.0;

    half4 yellow = content.eval(refractedCoord + dispersedCoord * (1.0 / 3.0));
    color.r += yellow.r / 3.5;
    color.g += yellow.g / 3.5;
    color.a += yellow.a / 7.0;

    half4 green = content.eval(refractedCoord);
    color.g += green.g / 3.5;
    color.a += green.a / 7.0;

    half4 cyan = content.eval(refractedCoord - dispersedCoord * (1.0 / 3.0));
    color.g += cyan.g / 3.5;
    color.b += cyan.b / 3.0;
    color.a += cyan.a / 7.0;

    half4 blue = content.eval(refractedCoord - dispersedCoord * (2.0 / 3.0));
    color.b += blue.b / 3.0;
    color.a += blue.a / 7.0;

    half4 purple = content.eval(refractedCoord - dispersedCoord);
    color.r += purple.r / 7.0;
    color.b += purple.b / 3.0;
    color.a += purple.a / 7.0;

    return color;
}

half4 main(float2 coord) {
    float2 halfSize = size * 0.5;
    float2 centeredCoord = coord - halfSize;
    float radius = radiusAt(centeredCoord, cornerRadii);

    float sd = sdRoundedRect(centeredCoord, halfSize, radius);
    float h = max(refractionHeight, 0.001);

    // Flat center region: no refraction.
    if (-sd >= h) {
        return content.eval(coord);
    }

    // Only care about inside. Outside will be clipped in C#.
    sd = min(sd, 0.0);

    float d = circleMap(1.0 - (-sd / h)) * refractionAmount;
    float gradRadius = min(radius * 1.5, min(halfSize.x, halfSize.y));
    float2 grad = gradSdRoundedRect(centeredCoord, halfSize, gradRadius);
    grad = normalize(grad + depthEffect * normalize(centeredCoord));

    float2 refractedCoord = coord + d * grad;

    half4 result;
    if (chromaticAberration <= 0.001) {
        result = content.eval(refractedCoord);
    } else {
        float denom = max(halfSize.x * halfSize.y, 0.001);
        float dispersionIntensity = chromaticAberration * ((centeredCoord.x * centeredCoord.y) / denom);
        float2 dispersedCoord = d * grad * dispersionIntensity;
        result = sampleDispersed(refractedCoord, dispersedCoord);
    }
    return result;
}
